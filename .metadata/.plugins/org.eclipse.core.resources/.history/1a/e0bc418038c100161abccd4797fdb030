package week5;

import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

public class MapUtil {
	//@ ensures  

//	public static <K, V> boolean isOneOnOne(Map<K, V> map) {
//
//		boolean result = true;
//		
//        for (V value : map.values()) {
//            int i = 0;
//            for (K key : map.keySet()) {
//                if (value.equals(map.get(key))) i++;
//                if (i > 1) result = !result;
//            }
//        }
//        return result;
//    }
	//@ ensures \result == (\forall int i, j; 0 <= i & i < j & j < f.size(); f.get(i) != f.get(j));
	public static <K, V> boolean isOneOnOne(Map<K, V> f) {
		boolean isOneOnOne = true;
		
		Object v = null;
		for (int i = 0; i < f.size() && isOneOnOne; i++) {
			if (i != 0 && v == f.get(i)) {
				isOneOnOne = false;
			}
			v = f.get(i);
		}
		
		return isOneOnOne;
	}
	
	public static <K, V> 
	boolean isSurjectiveOnRange(Map<K, V> map, Set<V> range) {
		// TODO: implement, see exercise P-5.2
		return false;
	}
	public static <K, V> Map<V, Set<K>> inverse(Map<K, V> map) {
		// TODO: implement, see exercise P-5.3
		return null;
	}
	public static <K, V> Map<V, K> inverseBijection(Map<K, V> map) {
		// TODO: implement, see exercise P-5.3
		return null;
	}
	public static <K, V, W> boolean compatible(Map<K, V> f, Map<V, W> g) {
		// TODO: implement, see exercise P-5.4
		return false;
	}
	public static <K, V, W> Map<K, W> compose(Map<K, V> f, Map<V, W> g) {
		// TODO: implement, see exercise P-5.5
		return null;
	}
}
